        st.header("Trading Agent Configuration")

        # Input parameters
        st.subheader("Training Options")
        stock_name = st.text_input("Training Stock Symbol", value="AAPL")

        # Environment parameters
        st.header("Environment Parameters")
        col1, col2 = st.columns(2)
        with col1:
            initial_balance = st.number_input("Initial Balance", value=10000)

        with col2:
            transaction_cost = st.number_input("Transaction Cost",
                                               value=0.01,
                                               step=0.001)

        env_params = {
            'initial_balance': initial_balance,
            'transaction_cost': transaction_cost,
            'use_position_profit': False,
            'use_holding_bonus': False,
            'use_trading_penalty': False
        }

        # Date selection for training
        st.subheader("Training Period")
        train_col1, train_col2 = st.columns(2)
        with train_col1:
            train_start_date = datetime.combine(
                st.date_input("Training Start Date",
                              value=datetime.now() - timedelta(days=365 * 5)),
                datetime.min.time())
        with train_col2:
            train_end_date = datetime.combine(
                st.date_input("Training End Date",
                              value=datetime.now() - timedelta(days=365 + 1)),
                datetime.min.time())

        tab1, tab2 = st.tabs(["Manual Parameters", "Hyperparameter Tuning"])

        with tab1:
            # Original manual parameter selection
            st.header("Agent Parameters")

            # Add checkbox to use Optuna parameters
            use_optuna_params = st.checkbox("Use Optuna Optimized Parameters",
                                            value=False)

            if use_optuna_params and st.session_state.ppo_params is not None:
                st.info("Using Optuna's optimized parameters")
                # Display Optuna parameters as read-only
                col3, col4 = st.columns(2)
                with col3:
                    st.text(
                        f"Learning Rate: {st.session_state.ppo_params['learning_rate']:.2e}"
                    )
                    st.text(
                        f"PPO Steps: {st.session_state.ppo_params['n_steps']}")
                    st.text(
                        f"Batch Size: {st.session_state.ppo_params['batch_size']}"
                    )
                    st.text(
                        f"Number of Epochs: {st.session_state.ppo_params['n_epochs']}"
                    )
                with col4:
                    st.text(
                        f"Gamma: {st.session_state.ppo_params['gamma']:.4f}")
                    st.text(
                        f"GAE Lambda: {st.session_state.ppo_params['gae_lambda']:.4f}"
                    )

                # Store Optuna values in variables
                learning_rate = st.session_state.ppo_params['learning_rate']
                ppo_steps = st.session_state.ppo_params['n_steps']
                batch_size = st.session_state.ppo_params['batch_size']
                n_epochs = st.session_state.ppo_params['n_epochs']
                gamma = st.session_state.ppo_params['gamma']
                gae_lambda = st.session_state.ppo_params['gae_lambda']
                clip_range = 0.2  # Default value for non-tuned parameter
                target_kl = 0.05  # Default value for non-tuned parameter
            else:
                if use_optuna_params:
                    st.warning(
                        "No Optuna parameters available. Please run hyperparameter tuning first."
                    )

                col3, col4 = st.columns(2)
                with col3:
                    learning_rate = st.number_input("Learning Rate",
                                                    value=3e-4,
                                                    format="%.1e")
                    ppo_steps = st.number_input("PPO Steps Per Update",
                                                value=512)
                    batch_size = st.number_input("Batch Size", value=128)
                    n_epochs = st.number_input("Number of Epochs", value=5)
                with col4:
                    gamma = st.number_input("Gamma (Discount Factor)",
                                            value=0.99)
                    clip_range = st.number_input("Clip Range", value=0.2)
                    target_kl = st.number_input("Target KL Divergence",
                                                value=0.05)

        with tab2:
            # Hyperparameter tuning section
            hyperparameter_tuning(stock_name, train_start_date, train_end_date,
                                  env_params)

        col_train, col_test = st.columns(2)

        if col_train.button("Start Training"):
            progress_bar = st.progress(0)
            status_placeholder = st.empty()

            ppo_params = {
                'learning_rate': learning_rate,
                'n_steps': ppo_steps,
                'batch_size': batch_size,
                'n_epochs': n_epochs,
                'gamma': gamma,
                'clip_range': clip_range,
                'target_kl': target_kl
            }

            progress_callback = ProgressBarCallback(
                total_timesteps=(train_end_date - train_start_date).days,
                progress_bar=progress_bar,
                status_placeholder=status_placeholder)

            metrics = st.session_state.model.train(stock_name=stock_name,
                                                   start_date=train_start_date,
                                                   end_date=train_end_date,
                                                   env_params=env_params,
                                                   ppo_params=ppo_params,
                                                   callback=progress_callback)

            if metrics:
                metrics_col1, metrics_col2, metrics_col3 = st.columns(3)
                with metrics_col1:
                    st.metric("Sharpe Ratio", f"{metrics['sharpe_ratio']:.2f}")
                    st.metric("Maximum Drawdown",
                              f"{metrics['max_drawdown']:.2%}")
                with metrics_col2:
                    st.metric("Sortino Ratio",
                              f"{metrics['sortino_ratio']:.2f}")
                    st.metric("Volatility", f"{metrics['volatility']:.2%}")
                with metrics_col3:
                    st.metric("Total Return", f"{metrics['total_return']:.2%}")
                    st.metric("Final Portfolio Value",
                              f"${metrics['final_value']:,.2f}")

            st.success("Training completed and model saved!")

        # Test period dates
        st.subheader("Test Period")
        test_col1, test_col2 = st.columns(2)
        with test_col1:
            test_start_date = datetime.combine(
                st.date_input("Test Start Date",
                              value=datetime.now() - timedelta(days=365)),
                datetime.min.time())
        with test_col2:
            test_end_date = datetime.combine(
                st.date_input("Test End Date", value=datetime.now()),
                datetime.min.time())

        if col_test.button("Test Model"):
            try:
                if not os.path.exists("trained_model.zip"):
                    st.error("Please train the model first before testing!")
                    return

                env_params = {
                    'initial_balance': initial_balance,
                    'transaction_cost': transaction_cost,
                }

                # Use either Optuna optimized or manual parameters
                test_ppo_params = st.session_state.ppo_params if use_optuna_params else {
                    'learning_rate': learning_rate,
                    'n_steps': ppo_steps,
                    'batch_size': batch_size,
                    'n_epochs': n_epochs,
                    'gamma': gamma,
                    'clip_range': clip_range,
                    'target_kl': target_kl
                }

                test_results = st.session_state.model.test(
                    stock_name=stock_name,
                    start_date=test_start_date,
                    end_date=test_end_date,
                    env_params=env_params,
                    ppo_params=test_ppo_params)

                with st.expander("Test Results", expanded=True):
                    col1, col2, col3 = st.columns(3)
                    metrics = test_results['metrics']

                    with col1:
                        st.metric("Sharpe Ratio",
                                  f"{metrics['sharpe_ratio']:.2f}")
                        st.metric("Maximum Drawdown",
                                  f"{metrics['max_drawdown']:.2%}")
                        st.metric(
                            "Total Return",
                            f"{(test_results['portfolio_history'][-1] - test_results['portfolio_history'][0]) / test_results['portfolio_history'][0]:.2%}"
                        )

                    with col2:
                        st.metric("Sortino Ratio",
                                  f"{metrics['sortino_ratio']:.2f}")
                        st.metric("Information Ratio",
                                  f"{metrics['information_ratio']:.2f}")
                        st.metric("Volatility", f"{metrics['volatility']:.2%}")

                    with col3:
                        st.metric(
                            "Final Portfolio Value",
                            f"${test_results['portfolio_history'][-1]:,.2f}")
                        st.metric(
                            "Initial Balance",
                            f"${test_results['portfolio_history'][0]:,.2f}")

                    # Plot portfolio value over time
                    st.subheader("Portfolio Value Over Time")
                    st.line_chart(
                        pd.DataFrame(test_results['portfolio_history'],
                                     columns=['Portfolio Value']))

                    # Create columns for charts
                    chart_col1, chart_col2 = st.columns(2)

                    with chart_col1:
                        if len(test_results['returns']) > 0:
                            fig = go.Figure(data=[
                                go.Histogram(x=test_results['returns'],
                                             nbinsx=50)
                            ])
                            fig.update_layout(title="Returns Distribution",
                                              xaxis_title="Return",
                                              yaxis_title="Frequency",
                                              showlegend=True)
                            st.plotly_chart(fig, use_container_width=True)

                        values = np.array(test_results['portfolio_history'])
                        peak = np.maximum.accumulate(values)
                        drawdowns = (peak - values) / peak
                        st.subheader("Drawdown Over Time")
                        st.area_chart(
                            pd.DataFrame(drawdowns, columns=['Drawdown']))

                    with chart_col2:
                        st.subheader("Agent Actions")
                        st.plotly_chart(test_results['action_plot'],
                                        use_container_width=True)

                        st.subheader("Price and Actions")
                        st.plotly_chart(test_results['combined_plot'],
                                        use_container_width=True)

                        st.subheader("Cumulative Returns")
                        cum_returns = pd.DataFrame(
                            np.cumprod(1 + test_results['returns']) - 1,
                            columns=['Returns'])
                        st.line_chart(cum_returns)

                        st.subheader("30-Day Rolling Volatility")
                        rolling_vol = pd.DataFrame(
                            test_results['returns'], columns=[
                                'Returns'
                            ]).rolling(30).std() * np.sqrt(252)
                        st.line_chart(rolling_vol)

            except Exception as e:
                st.error(f"Error during testing: {str(e)}")
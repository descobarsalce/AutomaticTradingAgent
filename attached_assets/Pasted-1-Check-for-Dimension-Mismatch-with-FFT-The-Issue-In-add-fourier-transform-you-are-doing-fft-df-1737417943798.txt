1. Check for Dimension Mismatch with FFT

The Issue
In add_fourier_transform, you are doing:

fft_df = pd.DataFrame({
    f'FFT_{i+1}': np.abs(fft_result[i]) for i in range(top_n)
}, index=[0])
return pd.concat([data.reset_index(drop=True), fft_df], axis=1)
data.reset_index(drop=True) will produce an N-row Series (one value per row).
fft_df is a 1-row DataFrame (the aggregate FFT coefficients).
If your Series has more than one row, pandas will raise a ValueError because it cannot concatenate an N-row object with a 1-row object along axis=1.

How to Fix
Store FFT results separately: Return the FFT in its own DataFrame rather than trying to combine it row-by-row. For example,
def add_fourier_transform(data: pd.Series, top_n: int = 5) -> pd.DataFrame:
    fft_result = fft(data.values)
    fft_values = {f'FFT_{i+1}': np.abs(fft_result[i]) for i in range(top_n)}
    # Return just a single-row dataframe or a dictionary for reference
    fft_df = pd.DataFrame([fft_values])  
    return fft_df
Then do not concatenate it with the main DataFrame row-wise.
Repeat FFT columns if you really want them row-wise: You might create columns for each row with the same FFT value repeated, but this is unusual analytically. If that’s desired, you can do:
fft_value_dict = {f'FFT_{i+1}': np.abs(fft_result[i]) for i in range(top_n)}
for col, val in fft_value_dict.items():
    data[col] = val  # repeated for all rows
return data
But note this means every row has identical FFT columns, which usually isn’t how FFT is used in time series.
2. Verify You Have Enough Data

You have various rolling windows (e.g., window=20 for Bollinger Bands, window=20 for volatility, up to lags=5 in lag features, RSI of 14, MACD up to 26, etc.). Each of these will introduce NaN values for the first N rows. Then you do:

prepared_df = prepared_df.dropna()
If your dataset is not large enough, you can end up dropping all rows. That will trigger the log warning:

"No valid data points remaining for {symbol} after calculations"
or leave an empty DataFrame that causes subsequent issues.

Steps to Fix or Verify:

Check the length of prepared_df after each step.
If you see it going to zero rows, consider:
Reducing your rolling windows.
Accepting some NaN values until you have enough historical data.
Removing fewer columns or using interpolation instead of simply dropping rows.
3. Ensure Required Columns are Present and Numeric

Your validation requires at least ['Close'] to be present. You also rely on Open, High, Low, Volume in other parts. If the DataFrame is missing these, the code can fail or log an error message:

if not validate_dataframe(data, ['Close']):
    logger.error(f"Invalid data format for {symbol}")
    continue
Check:

Are all these columns in the DataFrame?
Are they truly numeric? (Check df.dtypes to ensure they are float64 or int64, not object strings.)

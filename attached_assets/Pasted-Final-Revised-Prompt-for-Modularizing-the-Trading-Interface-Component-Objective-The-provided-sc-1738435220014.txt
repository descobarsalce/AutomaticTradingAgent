Final Revised Prompt for Modularizing the Trading Interface Component
ğŸš€ Objective:

The provided script is a monolithic implementation of a training interface for a trading agent. To improve team collaboration, maintainability, and scalability, we need to modularize it into independent components, enabling parallel development.

âš ï¸ STRICT CONSTRAINTS:

DO NOT modify the existing UI or main.py structure.
The UI and main app logic are already structured, and changes must not be made to them.
The orchestrator should be a separate background file (not main.py).
This file will handle coordination between training, testing, and hyperparameter tuning.
DO NOT modify external functions from other modules (utils.callbacks, core.visualization, core.base_agent, utils.stock_utils).
These functions belong to another team and must remain untouched.
If any changes seem necessary, explicit approval is required before making modifications.
Introduce a config.py file to centralize all parameters for training, testing, and hyperparameter tuning.
This ensures that parameter values are managed in one place, improving consistency and maintainability.
ğŸ›  Proposed Modularization Plan

1ï¸âƒ£ Training Logic
ğŸ“‚ File: core/training.py
Purpose:
Handles the execution of training logic, including model training and displaying results.
Uses pre-defined functions from other modules (without modifying them).
Functions to include:
run_training(ppo_params: Dict[str, Any])
display_training_metrics(metrics: Dict[str, float])
2ï¸âƒ£ Hyperparameter Optimization
ğŸ“‚ File: core/hyperparameter_tuning.py
Purpose:
Handles hyperparameter tuning using Optuna.
Provides results visualization.
Functions to include:
hyperparameter_tuning()
3ï¸âƒ£ Model Testing & Evaluation
ğŸ“‚ File: core/testing.py
Purpose:
Handles model evaluation on test data.
Displays performance metrics and trade visualizations.
Functions to include:
display_testing_interface(ppo_params, use_optuna_params=False)
4ï¸âƒ£ Orchestrator for Training, Testing, and Tuning
ğŸ“‚ File: core/orchestrator.py
Purpose:
Acts as a background orchestrator, not main.py.
Manages execution flow between training, testing, and tuning.
Responsibilities:
Calls run_training() from core/training.py when training is started.
Calls hyperparameter_tuning() from core/hyperparameter_tuning.py when tuning is started.
Calls display_testing_interface() from core/testing.py when testing is executed.
5ï¸âƒ£ Centralized Configuration File
ğŸ“‚ File: config.py
Purpose:
Stores all configurable parameters for training, testing, and hyperparameter tuning.
Provides a single source of truth for parameters to ensure consistency across modules.
Example Configuration Variables:
# config.py

TRAINING_PARAMS = {
    "initial_balance": 10000,
    "transaction_cost": 0.01,
    "use_position_profit": False,
    "use_holding_bonus": False,
    "use_trading_penalty": False
}

HYPERPARAM_TUNING_PARAMS = {
    "trials_number": 20,
    "pruning_enabled": True,
    "lr_min": 1e-5,
    "lr_max": 5e-4,
    "steps_min": 512,
    "steps_max": 2048,
    "batch_min": 64,
    "batch_max": 512,
    "epochs_min": 3,
    "epochs_max": 10,
    "gamma_min": 0.90,
    "gamma_max": 0.999,
    "gae_min": 0.90,
    "gae_max": 0.99
}

TESTING_PARAMS = {
    "test_start_offset_days": 365,
    "test_end_offset_days": 0
}
This ensures that all parameter adjustments happen in one place, avoiding hardcoded values inside different modules.
âœ… Final File Structure

project_root/
â”‚â”€â”€ core/
â”‚   â”œâ”€â”€ training.py          # Training execution logic
â”‚   â”œâ”€â”€ hyperparameter_tuning.py  # Hyperparameter tuning
â”‚   â”œâ”€â”€ testing.py           # Model evaluation and testing
â”‚   â”œâ”€â”€ orchestrator.py      # Background orchestrator (not main.py)
â”‚â”€â”€ utils/
â”‚   â”œâ”€â”€ code_execution.py    # Handles Python code execution
â”‚â”€â”€ config.py                # Centralized parameter configuration
â”‚â”€â”€ main.py                  # Unmodified main app file
ğŸš€ Implementation Requirements

Ensure each module has clear function definitions with docstrings describing inputs, outputs, and purpose.
Each module should interact with others only via defined APIsâ€”no direct function dependencies between unrelated components.
All parameters must be managed through config.py.
Orchestrator (core/orchestrator.py) must be a background script, separate from main.py.
Any required modifications to external functions must be explicitly approved before proceeding.
Final Revised Prompt for Modularizing the Trading Interface Component
🚀 Objective:

The provided script is a monolithic implementation of a training interface for a trading agent. To improve team collaboration, maintainability, and scalability, we need to modularize it into independent components, enabling parallel development.

⚠️ STRICT CONSTRAINTS:

DO NOT modify the existing UI or main.py structure.
The UI and main app logic are already structured, and changes must not be made to them.
The orchestrator should be a separate background file (not main.py).
This file will handle coordination between training, testing, and hyperparameter tuning.
DO NOT modify external functions from other modules (utils.callbacks, core.visualization, core.base_agent, utils.stock_utils).
These functions belong to another team and must remain untouched.
If any changes seem necessary, explicit approval is required before making modifications.
Introduce a config.py file to centralize all parameters for training, testing, and hyperparameter tuning.
This ensures that parameter values are managed in one place, improving consistency and maintainability.
🛠 Proposed Modularization Plan

1️⃣ Training Logic
📂 File: core/training.py
Purpose:
Handles the execution of training logic, including model training and displaying results.
Uses pre-defined functions from other modules (without modifying them).
Functions to include:
run_training(ppo_params: Dict[str, Any])
display_training_metrics(metrics: Dict[str, float])
2️⃣ Hyperparameter Optimization
📂 File: core/hyperparameter_tuning.py
Purpose:
Handles hyperparameter tuning using Optuna.
Provides results visualization.
Functions to include:
hyperparameter_tuning()
3️⃣ Model Testing & Evaluation
📂 File: core/testing.py
Purpose:
Handles model evaluation on test data.
Displays performance metrics and trade visualizations.
Functions to include:
display_testing_interface(ppo_params, use_optuna_params=False)
4️⃣ Orchestrator for Training, Testing, and Tuning
📂 File: core/orchestrator.py
Purpose:
Acts as a background orchestrator, not main.py.
Manages execution flow between training, testing, and tuning.
Responsibilities:
Calls run_training() from core/training.py when training is started.
Calls hyperparameter_tuning() from core/hyperparameter_tuning.py when tuning is started.
Calls display_testing_interface() from core/testing.py when testing is executed.
5️⃣ Centralized Configuration File
📂 File: config.py
Purpose:
Stores all configurable parameters for training, testing, and hyperparameter tuning.
Provides a single source of truth for parameters to ensure consistency across modules.
Example Configuration Variables:
# config.py

TRAINING_PARAMS = {
    "initial_balance": 10000,
    "transaction_cost": 0.01,
    "use_position_profit": False,
    "use_holding_bonus": False,
    "use_trading_penalty": False
}

HYPERPARAM_TUNING_PARAMS = {
    "trials_number": 20,
    "pruning_enabled": True,
    "lr_min": 1e-5,
    "lr_max": 5e-4,
    "steps_min": 512,
    "steps_max": 2048,
    "batch_min": 64,
    "batch_max": 512,
    "epochs_min": 3,
    "epochs_max": 10,
    "gamma_min": 0.90,
    "gamma_max": 0.999,
    "gae_min": 0.90,
    "gae_max": 0.99
}

TESTING_PARAMS = {
    "test_start_offset_days": 365,
    "test_end_offset_days": 0
}
This ensures that all parameter adjustments happen in one place, avoiding hardcoded values inside different modules.
✅ Final File Structure

project_root/
│── core/
│   ├── training.py          # Training execution logic
│   ├── hyperparameter_tuning.py  # Hyperparameter tuning
│   ├── testing.py           # Model evaluation and testing
│   ├── orchestrator.py      # Background orchestrator (not main.py)
│── utils/
│   ├── code_execution.py    # Handles Python code execution
│── config.py                # Centralized parameter configuration
│── main.py                  # Unmodified main app file
🚀 Implementation Requirements

Ensure each module has clear function definitions with docstrings describing inputs, outputs, and purpose.
Each module should interact with others only via defined APIs—no direct function dependencies between unrelated components.
All parameters must be managed through config.py.
Orchestrator (core/orchestrator.py) must be a background script, separate from main.py.
Any required modifications to external functions must be explicitly approved before proceeding.